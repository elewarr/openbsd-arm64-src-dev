Index: sys/arch/arm/arm/cpu.c
===================================================================
RCS file: /cvs/src/sys/arch/arm/arm/cpu.c,v
retrieving revision 1.59
diff -u -p -r1.59 cpu.c
--- sys/arch/arm/arm/cpu.c	24 Oct 2023 13:20:09 -0000	1.59
+++ sys/arch/arm/arm/cpu.c	2 Feb 2024 22:34:03 -0000
@@ -162,12 +162,16 @@ void
 cpu_identify(struct cpu_info *ci)
 {
 	uint32_t midr, impl, part;
+#if defined(CPU_ARMv7)
 	uint32_t clidr;
 	uint32_t ctr, ccsidr, sets, ways, line;
+	const char *sep;
+#elif defined(CPU_ARMv6)
+	uint32_t ctr;
+#endif /*CPU_ARMv6 */	
 	const char *impl_name = NULL;
 	const char *part_name = NULL;
 	const char *il1p_name = NULL;
-	const char *sep;
 	struct cpu_cores *coreselecter = cpu_cores_none;
 	int i;
 
@@ -220,6 +224,8 @@ cpu_identify(struct cpu_info *ci)
 		break;
 	}
 
+#if defined(CPU_ARMv7)
+
 	__asm volatile("mrc p15, 1, %0, c0, c0, 1" : "=r"(clidr));
 	for (i = 0; i < 7; i++) {
 		if ((clidr & CLIDR_CTYPE_MASK) == 0)
@@ -262,6 +268,7 @@ cpu_identify(struct cpu_info *ci)
 		}
 		clidr >>= 3;
 	}
+#endif /* CPU_ARMv7 */
 
 	/*
 	 * Some ARM processors are vulnerable to branch target
@@ -287,7 +294,11 @@ cpu_identify(struct cpu_info *ci)
 		case CPU_PART_CORTEX_A75:
 		default:
 			/* Vulnerable; flush BP cache. */
+#if defined(CPU_ARMv7)
 			ci->ci_flush_bp = armv7_flush_bp;
+#elif defined(CPU_ARMv6)
+			ci->ci_flush_bp = armv6_flush_bp;
+#endif
 			break;
 		case CPU_PART_CORTEX_A15:
 		case CPU_PART_CORTEX_A72:
@@ -297,7 +308,11 @@ cpu_identify(struct cpu_info *ci)
 			 * the magic bit in the ACTLR that actually
 			 * forces a BTB flush.
 			 */
-			ci->ci_flush_bp = cortex_a15_flush_bp;
+#if defined(CPU_ARMv7)
+		  ci->ci_flush_bp = cortex_a15_flush_bp;
+#elif defined(CPU_ARMv6)
+		  ci->ci_flush_bp = cpu_flush_bp_noop;		  
+#endif		  
 			break;
 		case CPU_PART_CORTEX_A57:
 			/*
