Index: sys/dev/fdt/pwmbl.c
===================================================================
RCS file: sys/dev/fdt/pwmbl.c
diff -N sys/dev/fdt/pwmbl.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/dev/fdt/pwmbl.c	8 Oct 2019 21:21:42 -0000
@@ -0,0 +1,219 @@
+/*	$OpenBSD$	*/
+/*
+ * Copyright (c) 2019 Krystian Lewandowski
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/device.h>
+#include <sys/malloc.h>
+
+#include <machine/fdt.h>
+#include <machine/bus.h>
+
+#include <dev/ofw/openfirm.h>
+#include <dev/ofw/ofw_gpio.h>
+#include <dev/ofw/ofw_misc.h>
+
+#include <dev/wscons/wsconsio.h>
+
+struct pwmbl_softc {
+	struct device		sc_dev;
+	uint32_t		*sc_pwm;
+	uint32_t		sc_period;
+	uint32_t		sc_flags;
+	uint32_t		sc_nlevels;
+	uint32_t		*sc_levels;
+	uint32_t		sc_def_level;
+};
+
+extern int			(*simplefb_read_cmd)(u_long, caddr_t);
+extern int			(*simplefb_write_cmd)(u_long, caddr_t);
+
+struct pwmbl_softc *sc_pwmbl;
+int	pwmbl_match(struct device *, void *, void *);
+void	pwmbl_attach(struct device *, struct device *, void *);
+int	pwmbl_get_brightness(void *, uint32_t *);
+int	pwmbl_set_brightness(void *, uint32_t);
+
+int	pwmbl_simplefb_read_cmd(ulong, caddr_t);
+int	pwmbl_simplefb_write_cmd(ulong, caddr_t);
+
+struct cfattach pwmbl_ca = {
+	sizeof (struct pwmbl_softc), pwmbl_match, pwmbl_attach
+};
+
+struct cfdriver pwmbl_cd = {
+	NULL, "pwmbl", DV_DULL
+};
+
+int
+pwmbl_match(struct device *parent, void *match, void *aux)
+{
+	struct fdt_attach_args *faa = aux;
+
+	return OF_is_compatible(faa->fa_node, "pwm-backlight");
+}
+
+void
+pwmbl_attach(struct device *parent, struct device *self, void *aux)
+{
+	struct pwmbl_softc *sc = (struct pwmbl_softc *)self;
+	struct fdt_attach_args *faa = aux;
+
+	uint32_t *gpios;
+	int len;
+
+	len = OF_getproplen(faa->fa_node, "pwms");
+	if (len <= 12) {
+		printf(": no pwm\n");
+		return;
+	}
+
+	sc->sc_pwm = malloc(len, M_DEVBUF, M_WAITOK);
+	OF_getpropintarray(faa->fa_node, "pwms", sc->sc_pwm, len);
+
+	sc->sc_period = sc->sc_pwm[2];
+	if(len >= 16) {
+		sc->sc_flags = sc->sc_pwm[3];
+	} else {
+		sc->sc_flags = 0;
+	}
+
+	len = OF_getproplen(faa->fa_node, "enable-gpios");
+	if (len < 0) {
+		printf(": no gpio\n");
+		return;
+	}
+
+	gpios = malloc(len, M_TEMP, M_WAITOK);
+	OF_getpropintarray(faa->fa_node, "enable-gpios", gpios, len);
+	gpio_controller_config_pin(&gpios[0], GPIO_CONFIG_OUTPUT);
+	gpio_controller_set_pin(&gpios[0], 1);
+	free(gpios, M_TEMP, len);
+
+	len = OF_getproplen(faa->fa_node, "brightness-levels");
+	if (len < 0) {
+		printf(": no brightness levels\n");
+		return;
+	}
+
+	printf("\n");
+
+	sc->sc_levels = malloc(len, M_DEVBUF, M_WAITOK);
+	OF_getpropintarray(faa->fa_node, "brightness-levels",
+	    sc->sc_levels, len);
+	sc->sc_nlevels = len / sizeof(uint32_t);
+
+	sc->sc_def_level = OF_getpropint(faa->fa_node, "default-brightness-level",
+	    sc->sc_levels[sc->sc_nlevels-1]);
+
+	// TODO: let simplefb to manage brightness via pwmbl
+	sc_pwmbl = sc;
+	simplefb_read_cmd = pwmbl_simplefb_read_cmd;
+	simplefb_write_cmd = pwmbl_simplefb_write_cmd;
+}
+
+int
+pwmbl_get_brightness(void *cookie, uint32_t *level) {
+	struct pwmbl_softc *sc = cookie;
+	struct pwm_state ps;
+	uint32_t bl_val;
+	int i;
+
+	if (pwm_get_state(sc->sc_pwm, &ps))
+		return EINVAL;
+
+	bl_val = (ps.ps_pulse_width * sc->sc_levels[sc->sc_nlevels - 1]) / sc->sc_period;
+
+	for (i = 0; i < sc->sc_nlevels; i++) {
+		if (bl_val <= sc->sc_levels[i]) {
+			*level = i;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+int
+pwmbl_set_brightness(void *cookie, uint32_t level) {
+	struct pwmbl_softc *sc = cookie;
+	struct pwm_state ps;
+
+	if (pwm_init_state(sc->sc_pwm, &ps))
+		return EINVAL;
+
+	ps.ps_period = sc->sc_period;
+	ps.ps_flags = sc->sc_flags;
+	ps.ps_enabled = 1;
+	ps.ps_pulse_width = (sc->sc_period * sc->sc_levels[level]) / sc->sc_levels[sc->sc_nlevels - 1];
+	return pwm_set_state(sc->sc_pwm, &ps);
+}
+
+// TODO: find a better way for simplefb to manage brightness via pwmbl
+int
+pwmbl_simplefb_read_cmd(ulong cmd, caddr_t data)
+{
+	struct wsdisplay_param *dp = (struct wsdisplay_param *)data;
+	struct pwmbl_softc *sc = (struct pwmbl_softc *)sc_pwmbl;
+	uint32_t level;
+
+	switch (cmd) {
+	case WSDISPLAYIO_GETPARAM:
+		switch (dp->param) {
+		case WSDISPLAYIO_PARAM_BRIGHTNESS:
+			dp->min = sc->sc_levels[0];
+			dp->max = sc->sc_levels[sc->sc_nlevels - 1];
+
+			if (pwmbl_get_brightness(sc, &level) >= 0) {
+				dp->curval = sc->sc_levels[level];
+				return 0;
+			}
+			break;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return -1;
+}
+
+int
+pwmbl_simplefb_write_cmd(ulong cmd, caddr_t data)
+{
+	struct wsdisplay_param *dp = (struct wsdisplay_param *)data;
+	struct pwmbl_softc *sc = (struct pwmbl_softc *)sc_pwmbl;
+	u_int i;
+
+	switch (cmd) {
+	case WSDISPLAYIO_SETPARAM:
+		switch (dp->param) {
+		case WSDISPLAYIO_PARAM_BRIGHTNESS:
+			for (i = 0; i < sc->sc_nlevels; i++) {
+				if (dp->curval <= sc->sc_levels[i])
+					break;
+			}
+
+			if (pwmbl_set_brightness(sc, i) >= 0)
+				return 0;
+			break;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return -1;
+}
