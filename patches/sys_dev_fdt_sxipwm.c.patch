Index: sys/dev/fdt/sxipwm.c
===================================================================
RCS file: sys/dev/fdt/sxipwm.c
diff -N sys/dev/fdt/sxipwm.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/dev/fdt/sxipwm.c	6 Oct 2019 09:51:35 -0000
@@ -0,0 +1,323 @@
+/*	$OpenBSD$	*/
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/device.h>
+#include <sys/malloc.h>
+
+#include <machine/fdt.h>
+#include <machine/bus.h>
+
+#include <dev/pwm/pwmvar.h>
+#include <dev/ofw/openfirm.h>
+#include <dev/ofw/ofw_clock.h>
+#include <dev/ofw/ofw_pinctrl.h>
+#include <dev/ofw/fdt.h>
+
+#define PWM_CTRL_REG		0x0
+#define PWM_CH0_PERIOD		0x4
+#define PWM_CH0_PRESCAL	0xf
+
+#define PWM0_RDY		(1 << 28)
+#define PWM0_BYPASS		(1 << 9)
+#define PWM_CH0_MODE		(1 << 7)
+#define SCLK_CH0_GATING	(1 << 6)
+#define PWM_CH0_ACT_STA	(1 << 5)
+#define PWM_CH0_EN		(1 << 4)
+
+#define PWM_CH0_CYCLES_SHIFT		16
+#define PWM_CH0_ACT_CYCLES_SHIFT	0
+#define PWM_CH0_CYCLES_MASK		0xffff
+#define PWM_CH0_CYCLES_MAX		0xffff
+
+#define NS_PER_S		1000000000
+
+#define HREAD4(sc, reg)					\
+(bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)))
+#define HWRITE4(sc, reg, val)					\
+bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
+
+struct sxipwm_prescaler {
+	uint32_t	divider;
+	uint8_t	mask;
+};
+
+struct sxipwm_prescaler a64_prescalers[] = {
+	{ 1, 0xf },
+	{ 120, 0x0 },
+	{ 180, 0x1 },
+	{ 240, 0x2 },
+	{ 360, 0x3 },
+	{ 480, 0x4 },
+	{ 12000, 0x8 },
+	{ 24000, 0x9 },
+	{ 36000, 0xa },
+	{ 48000, 0xb },
+	{ 72000, 0xc },
+	{ 0 }
+};
+
+struct sxipwm_softc {
+	struct device		sc_dev;
+	bus_space_tag_t	sc_iot;
+	bus_space_handle_t	sc_ioh;
+	int			sc_node;
+
+	struct pwm_controller	sc_tag;
+
+	uint32_t		sc_freq;
+	struct sxipwm_prescaler *sc_prescalers;
+};
+
+int	sxipwm_match(struct device *, void *, void *);
+void	sxipwm_attach(struct device *, struct device *, void *);
+void	sxipwm_scan(struct sxipwm_softc *);
+int	sxipwm_enable(void *);
+int	sxipwm_disable(void *);
+int	sxipwm_get_config(void *, struct pwm_config *);
+int	sxipwm_set_config(void *, struct pwm_config *);
+
+struct cfattach sxipwm_ca = {
+	sizeof (struct sxipwm_softc), sxipwm_match, sxipwm_attach
+};
+
+struct cfdriver sxipwm_cd = {
+	NULL, "sxipwm", DV_DULL
+};
+
+int
+sxipwm_match(struct device *parent, void *match, void *aux)
+{
+	struct fdt_attach_args *faa = aux;
+
+	return OF_is_compatible(faa->fa_node, "allwinner,sun50i-a64-pwm");
+}
+
+void
+sxipwm_attach(struct device *parent, struct device *self, void *aux)
+{
+	struct sxipwm_softc *sc = (struct sxipwm_softc *)self;
+	struct fdt_attach_args *faa = aux;
+
+	if (faa->fa_nreg < 1) {
+		printf(": no registers\n");
+		return;
+	}
+
+	sc->sc_freq = clock_get_frequency_idx(faa->fa_node, 0);
+	if (sc->sc_freq == 0) {
+		printf(": no clock\n");
+		return;
+	}
+
+	sc->sc_iot = faa->fa_iot;
+	sc->sc_node = faa->fa_node;
+	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
+	    faa->fa_reg[0].size, 0, &sc->sc_ioh)) {
+		printf(": can't map registers\n");
+		return;
+	}
+
+	printf("\n");
+
+	pinctrl_byname(sc->sc_node, "default");
+
+	clock_enable_all(sc->sc_node);
+	reset_deassert_all(sc->sc_node);
+
+	if (OF_is_compatible(faa->fa_node, "allwinner,sun50i-a64-pwm")) {
+		sc->sc_prescalers = a64_prescalers;
+	}
+
+	if (sc->sc_prescalers == NULL) {
+		return;
+	}
+
+	sxipwm_enable(sc);
+
+	sc->sc_tag.pc_cookie = sc;
+	sc->sc_tag.pc_enable = sxipwm_enable;
+	sc->sc_tag.pc_disable = sxipwm_disable;
+	sc->sc_tag.pc_set_config = sxipwm_set_config;
+	sc->sc_tag.pc_get_config = sxipwm_get_config;
+
+	sxipwm_scan(sc);
+}
+
+void
+sxipwm_scan(struct sxipwm_softc *sc)
+{
+	struct pwm_attach_args pa;
+	char name[32];
+	int len, pwm_node, node = OF_finddevice("/");
+	uint32_t *pwms;
+
+	if (node == 0)
+		return;
+
+	for (node = OF_child(node); node; node = OF_peer(node)) {
+		memset(name, 0, sizeof(name));
+
+		if (OF_getprop(node, "compatible", name, sizeof(name)) == -1)
+			continue;
+
+		if (name[0] == '\0')
+			continue;
+
+		len = OF_getproplen(node, "pwms");
+		if (len < 0)
+			continue;
+
+		pwms = malloc(len, M_TEMP, M_WAITOK);
+		OF_getpropintarray(node, "pwms", pwms, len);
+		pwm_node = OF_getnodebyphandle(pwms[0]);
+		free(pwms, M_TEMP, len);
+
+		if (sc->sc_node != pwm_node)
+			continue;
+
+		memset(&pa, 0, sizeof(pa));
+		pa.pa_tag = &sc->sc_tag;
+		pa.pa_name = name;
+		pa.pa_cookie = &node;
+		pa.pa_channel = 0;
+
+		config_found(&sc->sc_dev, &pa, NULL);
+	}
+}
+
+int
+sxipwm_enable_arg(void *arg, int enable)
+{
+	struct sxipwm_softc *sc = arg;
+	uint32_t ctrl_reg;
+
+	ctrl_reg = HREAD4(sc, PWM_CTRL_REG);
+
+	if (ctrl_reg & PWM0_RDY) {
+		return EBUSY;
+	}
+
+	if (enable) {
+		ctrl_reg &= ~PWM0_BYPASS;
+		ctrl_reg &= ~PWM_CH0_MODE;
+		ctrl_reg |= (PWM_CH0_EN | SCLK_CH0_GATING);
+	} else {
+		ctrl_reg &= ~(PWM_CH0_EN | SCLK_CH0_GATING);
+	}
+
+	HWRITE4(sc, PWM_CTRL_REG, ctrl_reg);
+
+	return 0;
+}
+
+int
+sxipwm_enable(void *arg)
+{
+	return sxipwm_enable_arg(arg, 1);
+}
+
+int
+sxipwm_disable(void *arg)
+{
+
+	return sxipwm_enable_arg(arg, 0);
+}
+
+int
+sxipwm_get_config(void *arg, struct pwm_config *config)
+{
+	struct sxipwm_softc *sc = arg;
+	uint32_t ctrl_reg, ch_period_reg;
+	uint16_t cycles, act_cycles;
+	uint64_t rate;
+	int i, prescaler;
+
+	ctrl_reg = HREAD4(sc, PWM_CTRL_REG);
+	ch_period_reg = HREAD4(sc, PWM_CH0_PERIOD);
+
+	prescaler = -1;
+	for (i = 0; sc->sc_prescalers[i].divider; i++) {
+		if ((ctrl_reg & PWM_CH0_PRESCAL) == sc->sc_prescalers[i].mask) {
+			prescaler = i;
+		}
+	}
+
+	if (prescaler < 0) {
+		return EINVAL;
+	}
+
+	rate = sc->sc_freq / sc->sc_prescalers[prescaler].divider;
+	cycles = ((ch_period_reg >> PWM_CH0_CYCLES_SHIFT) + 1 ) & PWM_CH0_CYCLES_MASK;
+	act_cycles = (ch_period_reg >> PWM_CH0_ACT_CYCLES_SHIFT) & PWM_CH0_CYCLES_MASK;
+
+	config->pc_period = NS_PER_S / (rate / cycles);
+	config->pc_duty_cycle = NS_PER_S / (rate / act_cycles);
+
+	return 0;
+}
+
+int
+sxipwm_set_config(void *arg, struct pwm_config *config)
+{
+	struct sxipwm_softc *sc = arg;
+	uint16_t period = config->pc_period;
+	uint16_t duty_cycle = config->pc_duty_cycle;
+	uint32_t ctrl_reg, ch_period_reg;
+	uint16_t cycles, act_cycles;
+	uint64_t period_freq, duty_freq, rate;
+	int i, prescaler;
+
+	period_freq = NS_PER_S / period;
+
+	duty_cycle = duty_cycle ? duty_cycle : 1;
+
+	duty_freq = NS_PER_S / duty_cycle;
+
+	if (period_freq > sc->sc_freq) {
+		return EINVAL;
+	}
+
+	if (duty_freq < period_freq) {
+		return EINVAL;
+	}
+
+	prescaler = -1;
+	for (i = 0; sc->sc_prescalers[i].divider; i++) {
+		rate = sc->sc_freq / (period_freq * sc->sc_prescalers[i].divider);
+		if ((rate - 1) < PWM_CH0_CYCLES_MAX) {
+			prescaler = i;
+			break;
+		}
+	}
+
+	if (prescaler < 0) {
+		return EINVAL;
+	}
+
+	ctrl_reg = HREAD4(sc, PWM_CTRL_REG);
+
+	if (ctrl_reg & PWM0_RDY) {
+		return EBUSY;
+	}
+
+	if (config->pc_polarity == PWM_POLARITY_INVERTED) {
+		ctrl_reg &= ~PWM_CH0_ACT_STA;
+	} else {
+		ctrl_reg |= PWM_CH0_ACT_STA;
+	}
+
+	ctrl_reg &= ~PWM_CH0_PRESCAL;
+	ctrl_reg |= sc->sc_prescalers[prescaler].mask;
+	HWRITE4(sc, PWM_CTRL_REG, ctrl_reg);
+
+	rate = sc->sc_freq / sc->sc_prescalers[prescaler].divider;
+	cycles = rate / period_freq;
+	act_cycles = rate / duty_freq;
+
+	ch_period_reg = ((cycles - 1) << PWM_CH0_CYCLES_SHIFT) |
+	    (act_cycles << PWM_CH0_ACT_CYCLES_SHIFT);
+	HWRITE4(sc, PWM_CH0_PERIOD, ch_period_reg);
+
+	return 0;
+}
